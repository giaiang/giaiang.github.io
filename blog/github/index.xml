<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Github on Giaiang&#39;s Blog ٩(๑•̀ω•́๑)۶</title>
    <link>https://giaiang.github.io/blog/github/</link>
    <description>Recent content in Github on Giaiang&#39;s Blog ٩(๑•̀ω•́๑)۶</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <copyright>Copyright © 2020, Jane Doe.</copyright>
    <lastBuildDate>Mon, 21 Jul 2025 22:08:21 +0800</lastBuildDate>
    <atom:link href="https://giaiang.github.io/blog/github/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>IO多路复用</title>
      <link>https://giaiang.github.io/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Mon, 21 Jul 2025 22:08:21 +0800</pubDate>
      <guid>https://giaiang.github.io/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>&lt;p&gt;阻塞式I/O&#xA;非阻塞式I/O&#xA;信号驱动I/O&#xA;异步I/O&#xA;IO多路复用&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTTP</title>
      <link>https://giaiang.github.io/http/</link>
      <pubDate>Wed, 16 Jul 2025 21:52:49 +0800</pubDate>
      <guid>https://giaiang.github.io/http/</guid>
      <description>&lt;p&gt;HTTP状态码&lt;/p&gt;&#xA;&lt;p&gt;RFC规范，GET是安全且幂等的，因为它是“只读”的&#xA;POST是“新增或提交数据”的操作，会修改服务器上的数据，是不安全和不幂等的&lt;/p&gt;&#xA;&lt;p&gt;HTTP缓存技术&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;强制缓存：浏览器判断缓存没过期就使用浏览器本地缓存。（在HTTP响应头加入过期时间）&lt;/li&gt;&#xA;&lt;li&gt;协商缓存：发起请求后，由服务端判断是否可以使用本地缓存，是的话响应304。（基于Last-Modified最后修改时间/基于ETag唯一标识）&lt;/li&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>TCP/IP</title>
      <link>https://giaiang.github.io/tcp/ip/</link>
      <pubDate>Sun, 13 Jul 2025 22:00:43 +0800</pubDate>
      <guid>https://giaiang.github.io/tcp/ip/</guid>
      <description>&lt;h2 id=&#34;tcpudp&#34;&gt;TCP，UDP&lt;/h2&gt;&#xA;&lt;p&gt;TCP 是&lt;strong&gt;面向连接的、可靠的、基于字节流&lt;/strong&gt;的传输层通信协议。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;面向连接&lt;/strong&gt;：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;可靠的&lt;/strong&gt;：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;字节流&lt;/strong&gt;：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;TCP四元组：源地址，源端口，目标地址，目标端口&lt;/p&gt;&#xA;&lt;p&gt;TCP流式传输：将应用层的数据视为连续的字节序列，应用层自行处理边界，TCP不感知。TCP会将消息分片，为了分片后的消息不超过MTU，TCP数据的长度=IP总长度-IP首部长度-TCP首部长度。（MSS=MTU-IP头-TCP头）。Q:既然IP层有分片，TCP为啥还要分片？A：IP没有重传机制，丢了分片就得让TCP重新传，不分片的话TCP要重传整个报文。&#xA;UDP数据报传输：不拆分合并应用层的消息边界，分片由网络层IP协议处理（大于MTU）。&lt;/p&gt;&#xA;&lt;p&gt;TCP三次握手的目的：&#xA;同步初始序列号&#xA;验证双方的收发能力：例如第三次ACK确认后，服务器才能确认自己的SYN被客户端接收&#xA;防止已失效的连接请求突然传到服务器&#xA;为什么不能是两次握手：&#xA;单向确认问题：前两次握手后服务器无法确认客户端是否成功接收自己的SYN报文&#xA;序列号未完全同步：两次握手只能保证一方的序列号被确认，而另一方的序列号可能未被验证，导致数据传输错误。&#xA;防止历史连接：若有个旧的SYN报文到达服务器，服务器收到后发送SYN+ACK，然后进入连接建立状态（假设两次握手），客户端收到SYN+ACK后发现序列号不一样，发送RST，但此时服务器已经开始发送数据，白白浪费资源。&lt;/p&gt;&#xA;&lt;p&gt;每次TCP连接建立时，初始化的序列号要求都不一样。&lt;/p&gt;&#xA;&lt;p&gt;Q：为什么 TIME_WAIT 等待的时间是 2MSL？&#xA;A：自己理解，以最极限的情况来说，最后一个ACK到达被动关闭方的最晚时间是MSL，被动关闭方在0~MSL期间由于没有收到ACK会重传FIN，则FIN最晚到达主动关闭方的时间是2MSL。如果主动关闭方在2MSL内没有收到重传的FIN，则认为被动关闭方收到了ACK，断开连接。&lt;/p&gt;&#xA;&lt;p&gt;TCP重传、滑动窗口、流量控制、拥塞控制&lt;/p&gt;&#xA;&lt;p&gt;TCP重传&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;超时重传：超过RTO后重传（RTO应该略大于往返时延RTT）&lt;/li&gt;&#xA;&lt;li&gt;快速重传：收到三个相同的ACK时，重传丢失的报文，比如seq2丢失了，每次收到其他seq后都回复ACK2。（但是不知道要重传seq2还是seq2及之后的所有报文，所以有了SACK）&lt;/li&gt;&#xA;&lt;li&gt;SACK方法：TCP头部的“选项”中加入SACK，记录收到了哪些信息，回复给发送方。&lt;/li&gt;&#xA;&lt;li&gt;D-SACK：使用SACK告诉发送方哪些数据被重复&lt;strong&gt;接收&lt;/strong&gt;，可以判断ACK丢包和网络延时。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;滑动窗口：&lt;/p&gt;&#xA;&lt;p&gt;TCP每次发送一次数据都要应答，效率比较低。所以有了滑动窗口，窗口是操作系统上的一个缓存空间，只要不超过该窗口大小，就可以无需等待应答，继续发送数据，而每次收到应答后，将已经应答的数据从缓存区删除，同时还有&lt;strong&gt;累计应答&lt;/strong&gt;机制，即收到了ACK10，表示seq10之前的数据全都被收到了。&lt;/p&gt;&#xA;&lt;p&gt;窗口大小由接收端决定，接收端可以通过TCP头的Windows字段告诉发送方还有多少缓冲区。&lt;/p&gt;&#xA;&lt;p&gt;流量控制：滑动窗口是流量控制的实现基础，通过滑动窗口控制发送方的发送速率，确保发送速度不超过接收方的处理能。&lt;/p&gt;&#xA;&lt;p&gt;（操作系统缓冲区和滑动窗口的关系、糊涂窗口综合征）&lt;/p&gt;&#xA;&lt;p&gt;拥塞控制&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;慢启动：发送方每收到一个ACK，拥塞窗口cwnd大小+1（发送一个数据，收到一个ACK，cwnd变为2，发送两个数据，收到两个ACK，cwnd变为4，如此类推，1-&amp;gt;2-&amp;gt;4-&amp;gt;8）。到达慢启动门限后使用拥塞避免算法。&lt;/li&gt;&#xA;&lt;li&gt;拥塞避免&lt;/li&gt;&#xA;&lt;li&gt;拥塞发生&lt;/li&gt;&#xA;&lt;li&gt;快速恢复&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>使用Github Pages和Hugo搭建个人博客</title>
      <link>https://giaiang.github.io/%E4%BD%BF%E7%94%A8github-pages%E5%92%8Chugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sat, 12 Jul 2025 20:23:26 +0800</pubDate>
      <guid>https://giaiang.github.io/%E4%BD%BF%E7%94%A8github-pages%E5%92%8Chugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>&lt;h2 id=&#34;安装hugo&#34;&gt;安装Hugo&lt;/h2&gt;&#xA;&lt;p&gt;以Arch为例，运行 &lt;code&gt;pacman -S hugo&lt;/code&gt; 即可安装Hugo。&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建hugo项目&#34;&gt;创建Hugo项目&lt;/h2&gt;&#xA;&lt;h3 id=&#34;新建hugo项目&#34;&gt;新建Hugo项目&lt;/h3&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;hugo new site &amp;lt;项目名称&amp;gt;&lt;/code&gt; 创建一个新的博客项目，在当前目录下生成一个自定义名称的Hugo项目。&lt;/p&gt;&#xA;&lt;h3 id=&#34;导入主题&#34;&gt;导入主题&lt;/h3&gt;&#xA;&lt;p&gt;在 &lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;themes.gohugo.io&lt;/a&gt; 中挑选自己喜欢的主题，点击&lt;strong&gt;download&lt;/strong&gt;跳转到github页面，在已经创建的Hugo项目根目录下运行 &lt;code&gt;git submodule add &amp;lt;仓库链接&amp;gt; themes/&amp;lt;主题名称&amp;gt;&lt;/code&gt; 即可下载，例如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1&lt;/span&gt;&lt;span&gt;git submodule add https://github.com/janraasch/hugo-bearblog.git themes/hugo-bearblog&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下载的主题在Hugo项目的theme目录下，修改 &lt;code&gt;hugo.toml&lt;/code&gt; 配置文件，增加 &lt;code&gt;theme = &#39;&amp;lt;主题名称&amp;gt;&#39;&lt;/code&gt; 可以使用指定主题，或者将 &lt;code&gt;theme/exampleSite/hugo.toml&lt;/code&gt; 拷贝到Hugo项目根路径下（有些主题没有exampleSite）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;创建文章&#34;&gt;创建文章&lt;/h3&gt;&#xA;&lt;p&gt;使用 &lt;code&gt;hugo new &amp;lt;Markdown文件路径&amp;gt;&lt;/code&gt; 可以新建Markdown文件，创建的Markdown文件在 &lt;code&gt;content&lt;/code&gt; 目录下。&#xA;下面创建两个 &lt;code&gt;_index.md&lt;/code&gt; 文件和一个普通的Markdown文件，&lt;code&gt;_index.md&lt;/code&gt; 文件作为所在目录的首页：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;1&lt;/span&gt;&lt;span&gt;hugo new _index.md&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;2&lt;/span&gt;&lt;span&gt;hugo new blog/_index.md&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span style=&#34;white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f&#34;&gt;3&lt;/span&gt;&lt;span&gt;hugo new blog/my-new-page.md&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;_index.md&lt;/code&gt; 文件头部内容可能为（内容根据实际修改）：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
