<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://giaiang.github.io/images/favicon.png" />
<title>TCP/IP | Giaiang&#39;s Blog ٩(๑•̀ω•́๑)۶</title>
<meta name="title" content="TCP/IP" />
<meta name="description" content="TCP，UDP
TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。

面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

TCP四元组：源地址，源端口，目标地址，目标端口
TCP流式传输：将应用层的数据视为连续的字节序列，应用层自行处理边界，TCP不感知。TCP会将消息分片，为了分片后的消息不超过MTU，TCP数据的长度=IP总长度-IP首部长度-TCP首部长度。（MSS=MTU-IP头-TCP头）。Q:既然IP层有分片，TCP为啥还要分片？A：IP没有重传机制，丢了分片就得让TCP重新传，不分片的话TCP要重传整个报文。
UDP数据报传输：不拆分合并应用层的消息边界，分片由网络层IP协议处理（大于MTU）。
TCP三次握手的目的：
同步初始序列号
验证双方的收发能力：例如第三次ACK确认后，服务器才能确认自己的SYN被客户端接收
防止已失效的连接请求突然传到服务器
为什么不能是两次握手：
单向确认问题：前两次握手后服务器无法确认客户端是否成功接收自己的SYN报文
序列号未完全同步：两次握手只能保证一方的序列号被确认，而另一方的序列号可能未被验证，导致数据传输错误。
防止历史连接：若有个旧的SYN报文到达服务器，服务器收到后发送SYN&#43;ACK，然后进入连接建立状态（假设两次握手），客户端收到SYN&#43;ACK后发现序列号不一样，发送RST，但此时服务器已经开始发送数据，白白浪费资源。
每次TCP连接建立时，初始化的序列号要求都不一样。
Q：为什么 TIME_WAIT 等待的时间是 2MSL？
A：自己理解，以最极限的情况来说，最后一个ACK到达被动关闭方的最晚时间是MSL，被动关闭方在0~MSL期间由于没有收到ACK会重传FIN，则FIN最晚到达主动关闭方的时间是2MSL。如果主动关闭方在2MSL内没有收到重传的FIN，则认为被动关闭方收到了ACK，断开连接。
TCP重传、滑动窗口、流量控制、拥塞控制
TCP重传

超时重传：超过RTO后重传（RTO应该略大于往返时延RTT）
快速重传：收到三个相同的ACK时，重传丢失的报文，比如seq2丢失了，每次收到其他seq后都回复ACK2。（但是不知道要重传seq2还是seq2及之后的所有报文，所以有了SACK）
SACK方法：TCP头部的“选项”中加入SACK，记录收到了哪些信息，回复给发送方。
D-SACK：使用SACK告诉发送方哪些数据被重复接收，可以判断ACK丢包和网络延时。

滑动窗口：
TCP每次发送一次数据都要应答，效率比较低。所以有了滑动窗口，窗口是操作系统上的一个缓存空间，只要不超过该窗口大小，就可以无需等待应答，继续发送数据，而每次收到应答后，将已经应答的数据从缓存区删除，同时还有累计应答机制，即收到了ACK10，表示seq10之前的数据全都被收到了。
窗口大小由接收端决定，接收端可以通过TCP头的Windows字段告诉发送方还有多少缓冲区。
流量控制：滑动窗口是流量控制的实现基础，通过滑动窗口控制发送方的发送速率，确保发送速度不超过接收方的处理能。
（操作系统缓冲区和滑动窗口的关系、糊涂窗口综合征）
拥塞控制

慢启动：发送方每收到一个ACK，拥塞窗口cwnd大小&#43;1（发送一个数据，收到一个ACK，cwnd变为2，发送两个数据，收到两个ACK，cwnd变为4，如此类推，1-&gt;2-&gt;4-&gt;8）。到达慢启动门限后使用拥塞避免算法。
拥塞避免
拥塞发生
快速恢复
" />
<meta name="keywords" content="github,hugo,os," />


<meta property="og:url" content="https://giaiang.github.io/tcp/ip/">
  <meta property="og:site_name" content="Giaiang&#39;s Blog ٩(๑•̀ω•́๑)۶">
  <meta property="og:title" content="TCP/IP">
  <meta property="og:description" content="TCP，UDP TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。
面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的； 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端； 字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。 TCP四元组：源地址，源端口，目标地址，目标端口
TCP流式传输：将应用层的数据视为连续的字节序列，应用层自行处理边界，TCP不感知。TCP会将消息分片，为了分片后的消息不超过MTU，TCP数据的长度=IP总长度-IP首部长度-TCP首部长度。（MSS=MTU-IP头-TCP头）。Q:既然IP层有分片，TCP为啥还要分片？A：IP没有重传机制，丢了分片就得让TCP重新传，不分片的话TCP要重传整个报文。 UDP数据报传输：不拆分合并应用层的消息边界，分片由网络层IP协议处理（大于MTU）。
TCP三次握手的目的： 同步初始序列号 验证双方的收发能力：例如第三次ACK确认后，服务器才能确认自己的SYN被客户端接收 防止已失效的连接请求突然传到服务器 为什么不能是两次握手： 单向确认问题：前两次握手后服务器无法确认客户端是否成功接收自己的SYN报文 序列号未完全同步：两次握手只能保证一方的序列号被确认，而另一方的序列号可能未被验证，导致数据传输错误。 防止历史连接：若有个旧的SYN报文到达服务器，服务器收到后发送SYN&#43;ACK，然后进入连接建立状态（假设两次握手），客户端收到SYN&#43;ACK后发现序列号不一样，发送RST，但此时服务器已经开始发送数据，白白浪费资源。
每次TCP连接建立时，初始化的序列号要求都不一样。
Q：为什么 TIME_WAIT 等待的时间是 2MSL？ A：自己理解，以最极限的情况来说，最后一个ACK到达被动关闭方的最晚时间是MSL，被动关闭方在0~MSL期间由于没有收到ACK会重传FIN，则FIN最晚到达主动关闭方的时间是2MSL。如果主动关闭方在2MSL内没有收到重传的FIN，则认为被动关闭方收到了ACK，断开连接。
TCP重传、滑动窗口、流量控制、拥塞控制
TCP重传
超时重传：超过RTO后重传（RTO应该略大于往返时延RTT） 快速重传：收到三个相同的ACK时，重传丢失的报文，比如seq2丢失了，每次收到其他seq后都回复ACK2。（但是不知道要重传seq2还是seq2及之后的所有报文，所以有了SACK） SACK方法：TCP头部的“选项”中加入SACK，记录收到了哪些信息，回复给发送方。 D-SACK：使用SACK告诉发送方哪些数据被重复接收，可以判断ACK丢包和网络延时。 滑动窗口：
TCP每次发送一次数据都要应答，效率比较低。所以有了滑动窗口，窗口是操作系统上的一个缓存空间，只要不超过该窗口大小，就可以无需等待应答，继续发送数据，而每次收到应答后，将已经应答的数据从缓存区删除，同时还有累计应答机制，即收到了ACK10，表示seq10之前的数据全都被收到了。
窗口大小由接收端决定，接收端可以通过TCP头的Windows字段告诉发送方还有多少缓冲区。
流量控制：滑动窗口是流量控制的实现基础，通过滑动窗口控制发送方的发送速率，确保发送速度不超过接收方的处理能。
（操作系统缓冲区和滑动窗口的关系、糊涂窗口综合征）
拥塞控制
慢启动：发送方每收到一个ACK，拥塞窗口cwnd大小&#43;1（发送一个数据，收到一个ACK，cwnd变为2，发送两个数据，收到两个ACK，cwnd变为4，如此类推，1-&gt;2-&gt;4-&gt;8）。到达慢启动门限后使用拥塞避免算法。 拥塞避免 拥塞发生 快速恢复">
  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2025-07-13T22:00:43+08:00">
    <meta property="article:modified_time" content="2025-07-13T22:00:43+08:00">
    <meta property="article:tag" content="Github">
    <meta property="article:tag" content="Hugo">
    <meta property="article:tag" content="Os">
    <meta property="og:image" content="https://giaiang.github.io/images/share.png">




  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://giaiang.github.io/images/share.png">
  <meta name="twitter:title" content="TCP/IP">
  <meta name="twitter:description" content="TCP，UDP TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。
面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的； 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端； 字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。 TCP四元组：源地址，源端口，目标地址，目标端口
TCP流式传输：将应用层的数据视为连续的字节序列，应用层自行处理边界，TCP不感知。TCP会将消息分片，为了分片后的消息不超过MTU，TCP数据的长度=IP总长度-IP首部长度-TCP首部长度。（MSS=MTU-IP头-TCP头）。Q:既然IP层有分片，TCP为啥还要分片？A：IP没有重传机制，丢了分片就得让TCP重新传，不分片的话TCP要重传整个报文。 UDP数据报传输：不拆分合并应用层的消息边界，分片由网络层IP协议处理（大于MTU）。
TCP三次握手的目的： 同步初始序列号 验证双方的收发能力：例如第三次ACK确认后，服务器才能确认自己的SYN被客户端接收 防止已失效的连接请求突然传到服务器 为什么不能是两次握手： 单向确认问题：前两次握手后服务器无法确认客户端是否成功接收自己的SYN报文 序列号未完全同步：两次握手只能保证一方的序列号被确认，而另一方的序列号可能未被验证，导致数据传输错误。 防止历史连接：若有个旧的SYN报文到达服务器，服务器收到后发送SYN&#43;ACK，然后进入连接建立状态（假设两次握手），客户端收到SYN&#43;ACK后发现序列号不一样，发送RST，但此时服务器已经开始发送数据，白白浪费资源。
每次TCP连接建立时，初始化的序列号要求都不一样。
Q：为什么 TIME_WAIT 等待的时间是 2MSL？ A：自己理解，以最极限的情况来说，最后一个ACK到达被动关闭方的最晚时间是MSL，被动关闭方在0~MSL期间由于没有收到ACK会重传FIN，则FIN最晚到达主动关闭方的时间是2MSL。如果主动关闭方在2MSL内没有收到重传的FIN，则认为被动关闭方收到了ACK，断开连接。
TCP重传、滑动窗口、流量控制、拥塞控制
TCP重传
超时重传：超过RTO后重传（RTO应该略大于往返时延RTT） 快速重传：收到三个相同的ACK时，重传丢失的报文，比如seq2丢失了，每次收到其他seq后都回复ACK2。（但是不知道要重传seq2还是seq2及之后的所有报文，所以有了SACK） SACK方法：TCP头部的“选项”中加入SACK，记录收到了哪些信息，回复给发送方。 D-SACK：使用SACK告诉发送方哪些数据被重复接收，可以判断ACK丢包和网络延时。 滑动窗口：
TCP每次发送一次数据都要应答，效率比较低。所以有了滑动窗口，窗口是操作系统上的一个缓存空间，只要不超过该窗口大小，就可以无需等待应答，继续发送数据，而每次收到应答后，将已经应答的数据从缓存区删除，同时还有累计应答机制，即收到了ACK10，表示seq10之前的数据全都被收到了。
窗口大小由接收端决定，接收端可以通过TCP头的Windows字段告诉发送方还有多少缓冲区。
流量控制：滑动窗口是流量控制的实现基础，通过滑动窗口控制发送方的发送速率，确保发送速度不超过接收方的处理能。
（操作系统缓冲区和滑动窗口的关系、糊涂窗口综合征）
拥塞控制
慢启动：发送方每收到一个ACK，拥塞窗口cwnd大小&#43;1（发送一个数据，收到一个ACK，cwnd变为2，发送两个数据，收到两个ACK，cwnd变为4，如此类推，1-&gt;2-&gt;4-&gt;8）。到达慢启动门限后使用拥塞避免算法。 拥塞避免 拥塞发生 快速恢复">




  <meta itemprop="name" content="TCP/IP">
  <meta itemprop="description" content="TCP，UDP TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。
面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的； 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端； 字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。 TCP四元组：源地址，源端口，目标地址，目标端口
TCP流式传输：将应用层的数据视为连续的字节序列，应用层自行处理边界，TCP不感知。TCP会将消息分片，为了分片后的消息不超过MTU，TCP数据的长度=IP总长度-IP首部长度-TCP首部长度。（MSS=MTU-IP头-TCP头）。Q:既然IP层有分片，TCP为啥还要分片？A：IP没有重传机制，丢了分片就得让TCP重新传，不分片的话TCP要重传整个报文。 UDP数据报传输：不拆分合并应用层的消息边界，分片由网络层IP协议处理（大于MTU）。
TCP三次握手的目的： 同步初始序列号 验证双方的收发能力：例如第三次ACK确认后，服务器才能确认自己的SYN被客户端接收 防止已失效的连接请求突然传到服务器 为什么不能是两次握手： 单向确认问题：前两次握手后服务器无法确认客户端是否成功接收自己的SYN报文 序列号未完全同步：两次握手只能保证一方的序列号被确认，而另一方的序列号可能未被验证，导致数据传输错误。 防止历史连接：若有个旧的SYN报文到达服务器，服务器收到后发送SYN&#43;ACK，然后进入连接建立状态（假设两次握手），客户端收到SYN&#43;ACK后发现序列号不一样，发送RST，但此时服务器已经开始发送数据，白白浪费资源。
每次TCP连接建立时，初始化的序列号要求都不一样。
Q：为什么 TIME_WAIT 等待的时间是 2MSL？ A：自己理解，以最极限的情况来说，最后一个ACK到达被动关闭方的最晚时间是MSL，被动关闭方在0~MSL期间由于没有收到ACK会重传FIN，则FIN最晚到达主动关闭方的时间是2MSL。如果主动关闭方在2MSL内没有收到重传的FIN，则认为被动关闭方收到了ACK，断开连接。
TCP重传、滑动窗口、流量控制、拥塞控制
TCP重传
超时重传：超过RTO后重传（RTO应该略大于往返时延RTT） 快速重传：收到三个相同的ACK时，重传丢失的报文，比如seq2丢失了，每次收到其他seq后都回复ACK2。（但是不知道要重传seq2还是seq2及之后的所有报文，所以有了SACK） SACK方法：TCP头部的“选项”中加入SACK，记录收到了哪些信息，回复给发送方。 D-SACK：使用SACK告诉发送方哪些数据被重复接收，可以判断ACK丢包和网络延时。 滑动窗口：
TCP每次发送一次数据都要应答，效率比较低。所以有了滑动窗口，窗口是操作系统上的一个缓存空间，只要不超过该窗口大小，就可以无需等待应答，继续发送数据，而每次收到应答后，将已经应答的数据从缓存区删除，同时还有累计应答机制，即收到了ACK10，表示seq10之前的数据全都被收到了。
窗口大小由接收端决定，接收端可以通过TCP头的Windows字段告诉发送方还有多少缓冲区。
流量控制：滑动窗口是流量控制的实现基础，通过滑动窗口控制发送方的发送速率，确保发送速度不超过接收方的处理能。
（操作系统缓冲区和滑动窗口的关系、糊涂窗口综合征）
拥塞控制
慢启动：发送方每收到一个ACK，拥塞窗口cwnd大小&#43;1（发送一个数据，收到一个ACK，cwnd变为2，发送两个数据，收到两个ACK，cwnd变为4，如此类推，1-&gt;2-&gt;4-&gt;8）。到达慢启动门限后使用拥塞避免算法。 拥塞避免 拥塞发生 快速恢复">
  <meta itemprop="datePublished" content="2025-07-13T22:00:43+08:00">
  <meta itemprop="dateModified" content="2025-07-13T22:00:43+08:00">
  <meta itemprop="wordCount" content="53">
  <meta itemprop="image" content="https://giaiang.github.io/images/share.png">
  <meta itemprop="keywords" content="Github,Hugo,Os">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  :root {
    --width: 720px;
    --font-main: Verdana, sans-serif;
    --font-secondary: Verdana, sans-serif;
    --font-scale: 1em;
    --background-color: #fff;
    --heading-color: #222;
    --text-color: #444;
    --link-color: #3273dc;
    --visited-color: #8b6fcb;
    --code-background-color: #f2f2f2;
    --code-color: #222;
    --blockquote-color: #222;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      --background-color: #01242e;
      --heading-color: #eee;
      --text-color: #ddd;
      --link-color: #8cc2dd;
      --visited-color: #8b6fcb;
      --code-background-color: #000;
      --code-color: #ddd;
      --blockquote-color: #ccc;
    }
  }

  body {
    font-family: var(--font-secondary);
    font-size: var(--font-scale);
    margin: auto;
    padding: 20px;
    max-width: var(--width);
    text-align: left;
    background-color: var(--background-color);
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: var(--text-color);
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-family: var(--font-main);
    color: var(--heading-color);
  }

  a {
    color: var(--link-color);
    cursor: pointer;
    text-decoration: none;
  }

  a:hover {
    text-decoration: underline;
  }

  nav a {
    margin-right: 8px;
  }

  strong,
  b {
    color: var(--heading-color);
  }

  button {
    margin: 0;
    cursor: pointer;
  }

  time {
    font-family: monospace;
    font-style: normal;
    font-size: 15px;
  }

  main {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  hr {
    border: 0;
    border-top: 1px dashed;
  }

  img {
    max-width: 100%;
  }

  code {
    font-family: monospace;
    padding: 2px;
    background-color: var(--code-background-color);
    color: var(--code-color);
    border-radius: 3px;
  }

  blockquote {
    border-left: 1px solid #999;
    color: var(--code-color);
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px 0;
    text-align: center;
  }

  .title:hover {
    text-decoration: none;
  }

  .title h1 {
    font-size: 1.5em;
  }

  .inline {
    width: auto !important;
  }

  .highlight,
  .code {
    padding: 1px 15px;
    background-color: var(--code-background-color);
    color: var(--code-color);
    border-radius: 3px;
    margin-block-start: 1em;
    margin-block-end: 1em;
    overflow-x: auto;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: var(--visited-color);
  }

</style>

</head>

<body>
  <header><a href="/" class="title">
  <h2>Giaiang&#39;s Blog ٩(๑•̀ω•́๑)۶</h2>
</a>
<nav>
<a href="/">首页</a>

<a href="/blog/">博客</a>

<a href="/photography/">图集</a>

</nav>
</header>
  <main>

<h1>TCP/IP</h1>
<p>
  <i>
    <time datetime='2025-07-13'>
      13 Jul, 2025
    </time>
  </i>
</p>

<content>
  <h2 id="tcpudp">TCP，UDP</h2>
<p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li>
</ul>
<p>TCP四元组：源地址，源端口，目标地址，目标端口</p>
<p>TCP流式传输：将应用层的数据视为连续的字节序列，应用层自行处理边界，TCP不感知。TCP会将消息分片，为了分片后的消息不超过MTU，TCP数据的长度=IP总长度-IP首部长度-TCP首部长度。（MSS=MTU-IP头-TCP头）。Q:既然IP层有分片，TCP为啥还要分片？A：IP没有重传机制，丢了分片就得让TCP重新传，不分片的话TCP要重传整个报文。
UDP数据报传输：不拆分合并应用层的消息边界，分片由网络层IP协议处理（大于MTU）。</p>
<p>TCP三次握手的目的：
同步初始序列号
验证双方的收发能力：例如第三次ACK确认后，服务器才能确认自己的SYN被客户端接收
防止已失效的连接请求突然传到服务器
为什么不能是两次握手：
单向确认问题：前两次握手后服务器无法确认客户端是否成功接收自己的SYN报文
序列号未完全同步：两次握手只能保证一方的序列号被确认，而另一方的序列号可能未被验证，导致数据传输错误。
防止历史连接：若有个旧的SYN报文到达服务器，服务器收到后发送SYN+ACK，然后进入连接建立状态（假设两次握手），客户端收到SYN+ACK后发现序列号不一样，发送RST，但此时服务器已经开始发送数据，白白浪费资源。</p>
<p>每次TCP连接建立时，初始化的序列号要求都不一样。</p>
<p>Q：为什么 TIME_WAIT 等待的时间是 2MSL？
A：自己理解，以最极限的情况来说，最后一个ACK到达被动关闭方的最晚时间是MSL，被动关闭方在0~MSL期间由于没有收到ACK会重传FIN，则FIN最晚到达主动关闭方的时间是2MSL。如果主动关闭方在2MSL内没有收到重传的FIN，则认为被动关闭方收到了ACK，断开连接。</p>
<p>TCP重传、滑动窗口、流量控制、拥塞控制</p>
<p>TCP重传</p>
<ul>
<li>超时重传：超过RTO后重传（RTO应该略大于往返时延RTT）</li>
<li>快速重传：收到三个相同的ACK时，重传丢失的报文，比如seq2丢失了，每次收到其他seq后都回复ACK2。（但是不知道要重传seq2还是seq2及之后的所有报文，所以有了SACK）</li>
<li>SACK方法：TCP头部的“选项”中加入SACK，记录收到了哪些信息，回复给发送方。</li>
<li>D-SACK：使用SACK告诉发送方哪些数据被重复<strong>接收</strong>，可以判断ACK丢包和网络延时。</li>
</ul>
<p>滑动窗口：</p>
<p>TCP每次发送一次数据都要应答，效率比较低。所以有了滑动窗口，窗口是操作系统上的一个缓存空间，只要不超过该窗口大小，就可以无需等待应答，继续发送数据，而每次收到应答后，将已经应答的数据从缓存区删除，同时还有<strong>累计应答</strong>机制，即收到了ACK10，表示seq10之前的数据全都被收到了。</p>
<p>窗口大小由接收端决定，接收端可以通过TCP头的Windows字段告诉发送方还有多少缓冲区。</p>
<p>流量控制：滑动窗口是流量控制的实现基础，通过滑动窗口控制发送方的发送速率，确保发送速度不超过接收方的处理能。</p>
<p>（操作系统缓冲区和滑动窗口的关系、糊涂窗口综合征）</p>
<p>拥塞控制</p>
<ul>
<li>慢启动：发送方每收到一个ACK，拥塞窗口cwnd大小+1（发送一个数据，收到一个ACK，cwnd变为2，发送两个数据，收到两个ACK，cwnd变为4，如此类推，1-&gt;2-&gt;4-&gt;8）。到达慢启动门限后使用拥塞避免算法。</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>

</content>
<p>
  
  <a href="https://giaiang.github.io/blog/github/">#Github</a>
  
  <a href="https://giaiang.github.io/blog/hugo/">#Hugo</a>
  
  <a href="https://giaiang.github.io/blog/os/">#Os</a>
  
</p>

  </main>
  <footer>
</footer>

  
</body>

</html>
